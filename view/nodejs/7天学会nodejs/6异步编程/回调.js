function heavyCompute(n) {
    var count = 0,
        i, j;

    for (i = n; i > 0; --i) {
        for (j = n; j > 0; --j) {
            count += 1;
        }
    }
}

var t = new Date();

setTimeout(function () {
    console.log(new Date() - t);//=> 2547
}, 1000);

heavyCompute(50000);

/**
 * 通过如上案例，原本想要的结果是在1秒之后，输出1000毫秒数，但是，实际情况并不是这样。
 * 本来应该在1秒后被调用的回调函数,因为JS主线程忙于运行其它代码，实际执行时间被大幅延迟。
 * 
 * 
 * ，JS本身是单线程的，无法异步执行，
 * 因此我们可以认为setTimeout这类JS规范之外的由运行环境提供的特殊函数做的事情是，
 * 
 * *****创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，****************
 * *****并在收到平行进程的通知后再执行回调函数。*********************************
 * 
 * 除了setTimeout、setInterval这些常见的，这类函数还包括NodeJS提供的，
 * 诸如fs.readFile之类的异步API。
 * 
 * 
 * 我们仍然回到JS是单线程运行的这个事实上，
 * **************这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。************
 * 
 * 也就是说，
 * **************即使平行线程完成工作了，通知JS主线程执行回调函数了，***************
 * **************回调函数也要等到JS主线程空闲时才能开始执行************************
 * 
 */















